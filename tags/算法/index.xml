<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 不破楼兰终不还</title>
    <link>https://lovecoding.club/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 不破楼兰终不还</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 30 Dec 2018 21:45:09 +0800</lastBuildDate>
    
	<atom:link href="https://lovecoding.club/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode 235. 二叉搜索树的最近公共祖先</title>
      <link>https://lovecoding.club/2018/12/30/leetcode-235.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</link>
      <pubDate>Sun, 30 Dec 2018 21:45:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/12/30/leetcode-235.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</guid>
      <description>题目描述 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]
示例1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。  示例2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。  说明: * 所有节点的值都是唯一的 * p、q 为不同节点且均存在于给定的二叉搜索树中。
思路  两个不同节点，在树中存在4种状态，1：都在root的左子树中 2，都在root的右子树中 3，分别在root的左右子树中 4，其中一个节点为root节点 如果属于情况3，那么 root.</description>
    </item>
    
    <item>
      <title>LeetCode105. 从前序与中序遍历序列构造二叉树</title>
      <link>https://lovecoding.club/2018/12/15/leetcode105.-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</link>
      <pubDate>Sat, 15 Dec 2018 11:47:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/12/15/leetcode105.-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</guid>
      <description>描述 根据一棵树的前序遍历与中序遍历构造二叉树
注意:
你可以假设树中没有重复的元素。
例如，给出
前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7]  返回如下的二叉树：
 3 / \ 9 20 / \ 15 7  思路  前序遍历中，第一个节点即根节点 在中序遍历中，找出第一个节点的位置，根节点前面的 L 个数据，即根节点左子树的中序遍历数据，前序遍历中根节点后面的 L 个数据即左子树的前序遍历 右子树同上 简而言之，确定了根节点，确定了左子树和右子树的数据，递归对左子树和右子树进行重建  代码实现 // 根据一棵树的前序遍历与中序遍历构造二叉树 // TreeNode Definition for a binary tree node. type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } //前序遍历的第一个节点即根节点 res := &amp;amp;TreeNode{ Val: preorder[0], } if len(preorder) == 1 { return res } // 在中序遍历中，根节点前面的即根节点的左子树，后面的即右子树 //匿名函数 idx := func(val int, nums []int) int { for i, v := range nums { if v == val { return i } } return -1 }(res.</description>
    </item>
    
    <item>
      <title>一致性算法-Raft</title>
      <link>https://lovecoding.club/2018/12/08/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft.html</link>
      <pubDate>Sat, 08 Dec 2018 22:25:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/12/08/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft.html</guid>
      <description>Raft基础  一个Raft集群包含若干个节点，通常是5个，允许整个系统容忍2个节点的失效。 任何时刻每一个节点都处于三个状态之一：领导者、跟随者、候选人。通常，系统中只有一个领导人，其它节点都是跟随者。跟随者是被动的：不会发送任何请求，只是简单响应领导者或候选人的请求。领导者处理所有客户端请求。 Raft把时间分割成任意长度的任期，每个节点存储当前任期号，单调递增。服务器之间通信时会交换任期号，自动更新到较大任期号；如果一个候选人或领导者发现自己的任期号过期了，会立即恢复成跟随者状态  领导人选举  领导者周期性的向所有跟随者发送心跳包，如果跟随者在一定时间内未收到心跳包，即选举超时，会认为没有领导者，会递增自己的当前任期号并转成候选人，并发起选举，向其它节点发送RPC请求来给自己投票 当一个候选人获取大多数服务器节点针对同一任期号的选票，它成为领导人，并向其他服务器发送心跳建立自己的权威并组织新的领导者产生 每一个服务器节点最多会对一个任期号投出一张选票，按照先来先服务的原则 等待投票时，候选人可能收到领导者的附加日志项RPC，如果这个领导者的任期号大于等于候选人当前的任期号，即候选人会承认领导者合法并变回跟随者，如果任期号比自己小，那么会拒绝RPC并继续保持候选者 如果多个跟随者同时成为候选人，那么选票可能被瓜分以至于没有候选者可以得到大多数人的支持，此时每一个候选者都会超时，然后增加任期号，开始新一轮选举；Raft算法使用随机选举超时时间（150-300ms）的方式来确保很少会发生选票瓜分的情况，在大多数情况下，只有一个服务器会选举超时，然后赢得选举  日志复制  一旦领导人被选举出，就开始为客户端服务，每一个客户端请求都包含一条指令，领导人将指令作为一条新的日志附加到日志中，然后并行的发起RPC给其他服务器，让它们复制这条日志，当被安全的复制，领导人会应用这条日志到它的状态机中然后把结果返回给客户端 如果跟随者出现故障，领导者会不断重试直到所有跟随者都存储了所有日志（尽管已经回复了客户端） 在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖  安全性 在领导选举时增加一些限制，来保证任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目
选举限制  保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人 日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目 Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目 请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新  动画演示 Raft http://thesecretlivesofdata.com/raft/</description>
    </item>
    
    <item>
      <title>leetcode.398.随机数索引</title>
      <link>https://lovecoding.club/2018/11/16/leetcode.398.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95.html</link>
      <pubDate>Fri, 16 Nov 2018 10:50:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/16/leetcode.398.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95.html</guid>
      <description>题目描述 给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。
注意:
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。
示例:
int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); // pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。 solution.pick(3); // pick(1) 应该返回 0。因为只有nums[0]等于1。 solution.pick(1);  代码实现 // Solution defines a structure type Solution struct { nums []int } // Constructor constructs a object func Constructor(nums []int) Solution { return Solution{ nums: nums, } } // Pick returns index number that target at nums Randomly.</description>
    </item>
    
    <item>
      <title>leetcode 33 搜索旋转排序数组</title>
      <link>https://lovecoding.club/2018/11/13/leetcode.33.search-in-rotated-sorted-array.html</link>
      <pubDate>Tue, 13 Nov 2018 18:10:33 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/13/leetcode.33.search-in-rotated-sorted-array.html</guid>
      <description>题目描述 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
示例1：
输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4  示例2：
输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1  代码实现 //1. 先二分遍历找到分隔点index，特征是 &amp;lt; 前一个元素, &amp;gt;后一个元素; //2. 把数组分成二个部分，[0,index-1], [index,length-1]; //3. 分别使用二分查找，找到给定的值。 //时间复杂度为log(n). 不确定有什么更好的办法 func search(nums []int, target int) int { if len(nums) == 0 { return -1 } n := len(nums) - 1 divisionIndex := findDivision(nums) if divisionIndex == 0 || divisionIndex == -1 { //非旋转排序数组 return findTarget(nums, 0, n, target) } res := findTarget(nums, 0, divisionIndex-1, target) if res !</description>
    </item>
    
    <item>
      <title>leetcode.69.sqrtx.X的平方根</title>
      <link>https://lovecoding.club/2018/11/13/leetcode.69.sqrtx.html</link>
      <pubDate>Tue, 13 Nov 2018 14:08:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/13/leetcode.69.sqrtx.html</guid>
      <description>题目描述 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例1:
输入: 4 输出: 2  示例2:
输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。  暴力版本 // 暴力解法 func mySqrt(x int) int { for i := 0; i &amp;lt;= x; i++ { res := i * i if res == x { return i } else if res &amp;gt; x { return i - 1 } } return -1 }  二分查找 //在有序数组中，找到最后一个小于等于给定值的数 func mySqrt2(x int) int { low, high := 0, x for low &amp;lt;= high { //防止大数相加溢出 //位运算更高效 mid := low + (high-low)&amp;gt;&amp;gt;1 product := mid * mid if product &amp;gt; x { high = mid - 1 } else { if (mid == x) || (mid+1)*(mid+1) &amp;gt; x { //遍历最后一个数 || 下一个数大于目标值 return mid } //下一个数小于等于目标值，所以mid不是最后一个数 low = mid + 1 } } return -1 }  二分查找思路  相当于从0-x中找到最后一个平方&amp;lt;=x的整数 我们求解的是最后一个小于等于给定值的元素，所以当 product&amp;lt;=x时，需要确认 mid+1 的平方&amp;gt;x 如果 mid+1 的平方 &amp;lt;= x ,说明mid肯定不是最后一个，更新low  GitHub  源码传送门 项目中会提供各种数据结构及算法的Golang实现, LeetCode解题思路及答案  参考资料 leetcode 69.</description>
    </item>
    
    <item>
      <title>leetcode 25. k个一组翻转链表</title>
      <link>https://lovecoding.club/2018/10/27/leetcode25.-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</link>
      <pubDate>Sat, 27 Oct 2018 18:10:33 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/10/27/leetcode25.-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</guid>
      <description>题目描述 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。
示例:
给定这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5 当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5  说明: - 你的算法只能使用常数的额外空间。 - 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
解题思路 1. 取链表的前K个节点，如果够K个节点，就截断后进行反转，不够K个节点，说明处理完了，return 2. 反转完前K个节点后，使用递归，处理后面的链表  代码实现 // ListNode Definition for singly-linked list. type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { if k &amp;lt; 2 || head == nil || head.Next == nil { return head } tail, needReverse := getTail(head, k) if needReverse { tailNext := tail.</description>
    </item>
    
  </channel>
</rss>