<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>共识算法 on 不破楼兰终不还</title>
    <link>https://lovecoding.club/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 共识算法 on 不破楼兰终不还</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 12 Dec 2018 11:21:09 +0800</lastBuildDate>
    
	<atom:link href="https://lovecoding.club/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>共识机制-股份授权证明机制DPoS</title>
      <link>https://lovecoding.club/2018/12/12/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6-%E8%82%A1%E4%BB%BD%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E%E6%9C%BA%E5%88%B6dpos.html</link>
      <pubDate>Wed, 12 Dec 2018 11:21:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/12/12/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6-%E8%82%A1%E4%BB%BD%E6%8E%88%E6%9D%83%E8%AF%81%E6%98%8E%E6%9C%BA%E5%88%B6dpos.html</guid>
      <description> 原理  Delegated Proof of Stake，叫做股份授权证明机制（又称受托人机制），从某种角度来看，DPoS有点像是议会制度或人民代表大会制度。 如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。 DPoS充分利用了持股人的投票，以公平民主的方式达成共识，他们投票选出的N个见证人，可以视为N个矿池，而这N个矿池彼此的权利是完全相等的。 持股人可以随时通过投票更换这些见证人（矿池），只要他们提供的算力不稳定，计算机宕机，或者试图利用手中的权力作恶。  运行机制  所有持币者先选出受托人负责签署区块：选举过程比较类似由股东会选举出董事会（101人代表），代替股东会做出日常营运决策。授权董事会后，决策会更有效率 （相较于PoW每10分钟产生一个区块，DPoS每3秒钟即可产生一个区块。） 与PoW相同，DPoS的规则也是最长链胜出。其中每个受托人必须按照生产排程，轮流产生区块，拿一间工厂作为比方，假设排程排定A、Ｂ、Ｃ分别轮早、中、晚班生产，Ａ在晚上是无法刷门禁卡进入厂房生产的，同样地，C在早班时段也是无法进厂房的。 如果轮到某个超级节点时，他没能生产出区块，他将会从超级节点中除名，网络会选择新的超级节点取代他  对恶意节点的惩罚  注册成为候选受托人需要支付一笔保证金 惩罚机制为：不按排程产生区块的节点将在下一轮被投票剔除，也会被没收之前缴纳的保证金 虽然恶意的节点将在下一轮投票被踢出，但单个恶意区块在短期仍有可能是有效的状态。 短期虽然可能存在恶意区块，但长期下来，可以透过受托人的自主选择来回归链条的有效性  优点  能耗更低 出块时间更快，在交易中可以获得更快的确认速度  缺点  投票需要时间、精力以及技能，绝大部分普通用户是没有投票热情的 对于坏节点的处理存在诸多困难。社区选举不能及时有效的阻止一些破坏节点的出现，给网络造成安全隐患 POW简单来说一种没有门槛的算法，任何人都可以投入算力竞争区块奖励；DPoS延续了PoS的弊端,只有持币者才可以获得区块链奖励，其实这就带来了一种制度性门槛，最终导致DPOS币的流动性大大减少，穷者越穷，富者越富  </description>
    </item>
    
    <item>
      <title>共识机制-PoS权益证明</title>
      <link>https://lovecoding.club/2018/12/11/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6-pos%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E.html</link>
      <pubDate>Tue, 11 Dec 2018 23:44:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/12/11/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6-pos%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E.html</guid>
      <description>PoS简介 在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权
如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励
类似于现实生活中的股东机制，拥有股份越多的人越容易获取记账权
实现原理 常见的有两种：
1. proofhash &amp;lt; 币龄x目标值 2. proofhash &amp;lt; 币数x目标值  方式1缺点： - 部分节点平时保持离线，只在积累了可观的币龄以后才连线获取利息，然后再次离线
方式2优点： - 所有节点必须更多的保持在线，以进行权益累积。越多的节点在线进行权益累积，系统遭遇51%攻击的可能性就越低
PoS潜在攻击方法  账本分叉问题 ( Nothing at Stake Problem )
 在 PoW 机制中，当账本出现分叉时，对 PoW 这种算力敏感的算法，矿工必须选择一个方向进行挖矿。 而在 PoS 这种算力不敏感的时候，PoS 矿工往往会两个方向都挖，以争取实现利益最大化。当多数矿工都在两条链上一起挖矿的时候，就会很容易出现双重支付攻击。  冷启动问题 ( Initial Distribution Problem )
 PoS 机制中，由于持币量会对挖矿难度产生影响。因此，当一个基于 PoS 体系代币系统启动时，就会面临早期获得代币的持有者，没有动力去花费或者转移代币给第三方。同时，持有越多的币，越容易挖到矿，这样就产生了代币初始流通性问题。 解决方案：早起几个版本，通过 PoW 机制来创建货币，而非 PoS。由于 PoW 本身的性质，矿工在挖矿过程中往往需要资金来升级硬件，所以会让矿工手中的币流通起来  长距离攻击 ( Long-Range Attack )
 PoS 中，产生每个 Block 的速度相对 PoW 快了很多。因此，少数不怀好意的节点会想着把整个区块链共识账本全部重写。这在 PoW 中是经典的 51% 问题，即：当某一个节点控制了 51% 及以上算力，就有能力篡改账本，但达到 51% 算力是件极其困难的事情。而在 PoS 中缺乏对算力的约束，那么就存在潜在可能篡改账本。 解决方案：同步时，限制最大能接受的分叉节点数量。  贿赂攻击（Bribe Attack）</description>
    </item>
    
    <item>
      <title>一致性算法-Raft</title>
      <link>https://lovecoding.club/2018/12/08/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft.html</link>
      <pubDate>Sat, 08 Dec 2018 22:25:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/12/08/%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-raft.html</guid>
      <description>Raft基础  一个Raft集群包含若干个节点，通常是5个，允许整个系统容忍2个节点的失效。 任何时刻每一个节点都处于三个状态之一：领导者、跟随者、候选人。通常，系统中只有一个领导人，其它节点都是跟随者。跟随者是被动的：不会发送任何请求，只是简单响应领导者或候选人的请求。领导者处理所有客户端请求。 Raft把时间分割成任意长度的任期，每个节点存储当前任期号，单调递增。服务器之间通信时会交换任期号，自动更新到较大任期号；如果一个候选人或领导者发现自己的任期号过期了，会立即恢复成跟随者状态  领导人选举  领导者周期性的向所有跟随者发送心跳包，如果跟随者在一定时间内未收到心跳包，即选举超时，会认为没有领导者，会递增自己的当前任期号并转成候选人，并发起选举，向其它节点发送RPC请求来给自己投票 当一个候选人获取大多数服务器节点针对同一任期号的选票，它成为领导人，并向其他服务器发送心跳建立自己的权威并组织新的领导者产生 每一个服务器节点最多会对一个任期号投出一张选票，按照先来先服务的原则 等待投票时，候选人可能收到领导者的附加日志项RPC，如果这个领导者的任期号大于等于候选人当前的任期号，即候选人会承认领导者合法并变回跟随者，如果任期号比自己小，那么会拒绝RPC并继续保持候选者 如果多个跟随者同时成为候选人，那么选票可能被瓜分以至于没有候选者可以得到大多数人的支持，此时每一个候选者都会超时，然后增加任期号，开始新一轮选举；Raft算法使用随机选举超时时间（150-300ms）的方式来确保很少会发生选票瓜分的情况，在大多数情况下，只有一个服务器会选举超时，然后赢得选举  日志复制  一旦领导人被选举出，就开始为客户端服务，每一个客户端请求都包含一条指令，领导人将指令作为一条新的日志附加到日志中，然后并行的发起RPC给其他服务器，让它们复制这条日志，当被安全的复制，领导人会应用这条日志到它的状态机中然后把结果返回给客户端 如果跟随者出现故障，领导者会不断重试直到所有跟随者都存储了所有日志（尽管已经回复了客户端） 在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖  安全性 在领导选举时增加一些限制，来保证任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目
选举限制  保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人 日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目 Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目 请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新  动画演示 Raft http://thesecretlivesofdata.com/raft/</description>
    </item>
    
  </channel>
</rss>