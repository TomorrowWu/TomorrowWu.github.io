<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>不破楼兰终不还</title>
    <link>https://lovecoding.club/</link>
    <description>Recent content on 不破楼兰终不还</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 16 Nov 2018 10:50:09 +0800</lastBuildDate>
    
	<atom:link href="https://lovecoding.club/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode.398.随机数索引</title>
      <link>https://lovecoding.club/2018/11/16/leetcode.398.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95.html</link>
      <pubDate>Fri, 16 Nov 2018 10:50:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/16/leetcode.398.%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95.html</guid>
      <description>题目描述 给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。
注意:
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。
示例:
int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); // pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。 solution.pick(3); // pick(1) 应该返回 0。因为只有nums[0]等于1。 solution.pick(1);  代码实现 // Solution defines a structure type Solution struct { nums []int } // Constructor constructs a object func Constructor(nums []int) Solution { return Solution{ nums: nums, } } // Pick returns index number that target at nums Randomly.</description>
    </item>
    
    <item>
      <title>左耳听风陈皓-程序员练级攻略2018开篇词-总结</title>
      <link>https://lovecoding.club/2018/11/15/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E9%99%88%E7%9A%93-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A52018%E5%BC%80%E7%AF%87%E8%AF%8D-%E6%80%BB%E7%BB%93.html</link>
      <pubDate>Thu, 15 Nov 2018 17:15:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/15/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E9%99%88%E7%9A%93-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A52018%E5%BC%80%E7%AF%87%E8%AF%8D-%E6%80%BB%E7%BB%93.html</guid>
      <description> 理论和现实的差距  学院派知识有强大威力,只是你没找到相关场景 算法与数据结构、操作系统原理、编译原理、数据库原理、计算机原理……这些原理上的东西，是你想要成为一个专家必需要学的东西。这就是“工人”和“工程师”的差别，是“建筑工人”和“建筑架构师”的差别。如果你觉得这些理论上的东西无用，那么只能说明，你只不过在从事工人的工作，而不是工程师的工作。  技术能力的瓶颈  技术的东西都是死的，这些死的知识只要努力就是可以学会的 只要你的方法得当，多花点时间在基础知识上，会让你未来学习应用知识的时间大大缩短 以绝大多数人努力的程度，和为自己不努力找借口的程度为参考，只要你坚持正常的学习就可以超过大多数人了  技术无法速成  一切都是要靠你自己去努力和持续地付出 成长路径是需要思考、精力和相关的经验的，这都需要时间，而且是不短的时间。你先问问自己有没有花十年磨一剑的决心  学习建议  一定要坚持，要保持长时间学习，甚至终生学习的态度 一定要动手，不管例子多么简单，建议至少自己动手敲一遍看看是否理解了里头的细枝末节 一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考 不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累，会在未来至少 10 年通用 回顾一下历史，看看历史时间线上技术的发展，你才能明白明天会是什么样的  我的观点  为明天做一些技术储备,因为你不知道你所缺的东西,机会只会留给有准备的人,多多阅读,多多交流,最好写下心得强化自己的认识和记忆 真正的高手在工作之余都会花很多时间去自己研究点东西 永远和高手一起工作。如果你面试的公司的面试太简单,就不要去,简单的面试意味着平庸,只会让你学习速度变慢,甚至倒退 很多东西在概念上是想通的,在哲学层次上是相通的,这是你需要去追求的学习知识的境界 很多时候,你缺少的不是知识,而是热情! 花2-3年打实基础，坚持学习基础原理，别看他们一开始跑的快，但是没有后劲，这跟长跑和登山一样，后半程随便秒他们  必读文章  传世之文《Teach Yourself Programming in Ten Years》（中英对照版） Coolshell 作者陈皓《程序员的荒谬之言还是至理名言？》  </description>
    </item>
    
    <item>
      <title>leetcode 33 搜索旋转排序数组</title>
      <link>https://lovecoding.club/2018/11/13/leetcode.33.search-in-rotated-sorted-array.html</link>
      <pubDate>Tue, 13 Nov 2018 18:10:33 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/13/leetcode.33.search-in-rotated-sorted-array.html</guid>
      <description>题目描述 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。
示例1：
输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4  示例2：
输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1  代码实现 //1. 先二分遍历找到分隔点index，特征是 &amp;lt; 前一个元素, &amp;gt;后一个元素; //2. 把数组分成二个部分，[0,index-1], [index,length-1]; //3. 分别使用二分查找，找到给定的值。 //时间复杂度为log(n). 不确定有什么更好的办法 func search(nums []int, target int) int { if len(nums) == 0 { return -1 } n := len(nums) - 1 divisionIndex := findDivision(nums) if divisionIndex == 0 || divisionIndex == -1 { //非旋转排序数组 return findTarget(nums, 0, n, target) } res := findTarget(nums, 0, divisionIndex-1, target) if res !</description>
    </item>
    
    <item>
      <title>leetcode.69.sqrtx.X的平方根</title>
      <link>https://lovecoding.club/2018/11/13/leetcode.69.sqrtx.html</link>
      <pubDate>Tue, 13 Nov 2018 14:08:09 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/11/13/leetcode.69.sqrtx.html</guid>
      <description>题目描述 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例1:
输入: 4 输出: 2  示例2:
输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。  暴力版本 // 暴力解法 func mySqrt(x int) int { for i := 0; i &amp;lt;= x; i++ { res := i * i if res == x { return i } else if res &amp;gt; x { return i - 1 } } return -1 }  二分查找 //在有序数组中，找到最后一个小于等于给定值的数 func mySqrt2(x int) int { low, high := 0, x for low &amp;lt;= high { //防止大数相加溢出 //位运算更高效 mid := low + (high-low)&amp;gt;&amp;gt;1 product := mid * mid if product &amp;gt; x { high = mid - 1 } else { if (mid == x) || (mid+1)*(mid+1) &amp;gt; x { //遍历最后一个数 || 下一个数大于目标值 return mid } //下一个数小于等于目标值，所以mid不是最后一个数 low = mid + 1 } } return -1 }  二分查找思路  相当于从0-x中找到最后一个平方&amp;lt;=x的整数 我们求解的是最后一个小于等于给定值的元素，所以当 product&amp;lt;=x时，需要确认 mid+1 的平方&amp;gt;x 如果 mid+1 的平方 &amp;lt;= x ,说明mid肯定不是最后一个，更新low  GitHub  源码传送门 项目中会提供各种数据结构及算法的Golang实现, LeetCode解题思路及答案  参考资料 leetcode 69.</description>
    </item>
    
    <item>
      <title>leetcode 25. k个一组翻转链表</title>
      <link>https://lovecoding.club/2018/10/27/leetcode25.-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</link>
      <pubDate>Sat, 27 Oct 2018 18:10:33 +0800</pubDate>
      
      <guid>https://lovecoding.club/2018/10/27/leetcode25.-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html</guid>
      <description>题目描述 给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。
示例:
给定这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5 当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5  说明: - 你的算法只能使用常数的额外空间。 - 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
解题思路 1. 取链表的前K个节点，如果够K个节点，就截断后进行反转，不够K个节点，说明处理完了，return 2. 反转完前K个节点后，使用递归，处理后面的链表  代码实现 // ListNode Definition for singly-linked list. type ListNode struct { Val int Next *ListNode } func reverseKGroup(head *ListNode, k int) *ListNode { if k &amp;lt; 2 || head == nil || head.Next == nil { return head } tail, needReverse := getTail(head, k) if needReverse { tailNext := tail.</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://lovecoding.club/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lovecoding.club/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>